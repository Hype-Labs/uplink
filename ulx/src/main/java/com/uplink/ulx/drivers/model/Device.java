package com.uplink.ulx.drivers.model;

/**
 * A device is an abstraction of a physical device as seen over some specific
 * transport type. For example, assuming the existence of a physical device A,
 * that device may have Bluetooth Classic and Bluetooth Low Energy enabled. For
 * other peers seeing both transports on the network, this will actually
 * correspond to two Device instances: one for device A over BLE, and another
 * one for device A over BLC. The problem of identifying whether the two
 * transports correspond to the same device is not solved at this point, and
 * instead is relegated to a protocol specifically designed to address that.
 * For example, after two devices connect, they exchange cryptographic keys
 * and issue each other an identification challenge; if the same identification
 * is seen (with proof given) for multiple Device instances, then the two
 * Device instances will be aggregated under the same Instance class, and the
 * two transports are seen as redundancy for each other. This redundancy will
 * be used for many reasons, such as recovering broken links, higher throughput,
 * and so on. From the type of abstraction that is being seen at this level,
 * however, a Device is nothing but a directly link to another peer. This also
 * means that devices seen over the mesh network do not correspond to a Device
 * instance, since those will not be present in line of sight (LoS). Other than
 * that, the Device instance aggregates a connector and its associated
 * transport, and has little functional value besides that. In fact, the
 * Connector and Stream instances do all the work.
 */
public interface Device {

    /**
     * This is a unique identifier that is assigned for each device,
     * corresponding to the device's identifier on the network. This identifier
     * is prefixed by the app's identifier and suffixed by an hexadecimal value
     * that is supposed to be unique within the domain of that app. In cases
     * where this identifier is generated by a server or some other sort of
     * centralized approach, the identifier is known to be unique, but in cases
     * where it's randomly generated collisions may occur. The current
     * specification does not determine how to deal with collisions, but it is
     * known that the identifier is long enough for those collisions to be
     * either very rare or non-existent. This identifier is also useful for
     * debug and JNI bridging purposes.
     * @return The device's network identifier.
     */
    String getIdentifier();

    /**
     * A device's transport type corresponds to the transport type over which
     * it is seen on the network. Only those that are visible in direct link
     * constitute a device, meaning that devices found in the mesh will not
     * be abstracted by this interface. This is the main distinction between
     * a Device and an Instance: the Device is an actual physical device over
     * a given transport type (e.g. Android device X over BLE), while an
     * instance is an abstraction of whichever transports map to the same
     * cryptographic challenges (e.g. some app running on device X, seen over
     * BLE or others).
     * @return The device's transport type.
     */
    int getTransportType();

    /**
     * Getter for the transport (e.g. reliable and unreliable I/O streams) for
     * this device.
     * @return The device's Transport.
     * @see Transport
     */
    Transport getTransport();

    /**
     * Getter for the device's connector.
     * @return The device's connector.
     * @see Connector
     */
    Connector getConnector();

    /**
     * Shortcut for {@code getTransport().getReliableChannel().getOutputStream()}
     */
    default OutputStream getOutputStream() {
        return getTransport().getReliableChannel().getOutputStream();
    }
}
